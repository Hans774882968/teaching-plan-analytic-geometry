import fs from 'fs';
import path from 'path';
import { parse } from '@babel/parser';
import traverse from '@babel/traverse';
import t from '@babel/types';
import { glob } from 'glob';
import { js_beautify } from 'js-beautify';
import { JS_BEAUTIFY_OPTIONS } from '../common/consts';
import chokidar from 'chokidar';

const FILE_NAME = 'geogebra-src-code-collect';
const collectionFilePath = path.resolve('src', 'appletOnLoadCollection.js');
const CONFIG_FILES_PATTERN = 'src/**/*{config,Config}.{js,jsx}';

export function getFunctionId(geogebraConfig, relativePath, functionCount) {
  const idProperty = geogebraConfig.properties.find(
    prop => t.isIdentifier(prop.key, { name: 'id' })
  );
  const fallbackFunctionId = encodeURI(`${relativePath}-${functionCount}`);
  if (!idProperty) {
    return fallbackFunctionId;
  }
  if (t.isStringLiteral(idProperty.value)) {
    const idVal = idProperty.value.value;
    return encodeURI(`${relativePath}-${idVal}`);
  }
  if (t.isTemplateLiteral(idProperty.value)) {
    // 简单处理模板字面量 - 只处理无表达式的简单情况
    if (idProperty.value.expressions.length === 0) {
      const idVal = idProperty.value.quasis[0].value.cooked;
      return encodeURI(`${relativePath}-${idVal}`);
    }
    return fallbackFunctionId;
  }
  return fallbackFunctionId;
}

export function getProcessedFunctionSource(functionSource) {
  const appletOnLoadFormattedCode = js_beautify(functionSource, JS_BEAUTIFY_OPTIONS);
  return encodeURI(appletOnLoadFormattedCode);
}

export function removeExistingAppletOnLoadIds(fileContent, relativePath) {
  try {
    const ast = parse(fileContent, {
      sourceType: 'module',
      plugins: ['jsx'],
    });

    const lines = fileContent.split('\n');
    const linesToRemove = new Set();

    traverse(ast, {
      ObjectProperty(path) {
        if (!t.isIdentifier(path.node.key, { name: 'appletOnLoadId' })) return;

        const loc = path.node.loc;
        if (!loc) return;

        // 记录属性所在行号（1-indexed）
        const lineNumber = loc.start.line;
        linesToRemove.add(lineNumber - 1); // 转换为0-indexed
      },
    });

    if (linesToRemove.size === 0) return fileContent;

    // 从后往前删除行，避免影响行号
    const newLines = lines.filter((_, idx) => !linesToRemove.has(idx));
    const newContent = newLines.join('\n');

    return newContent;
  } catch (error) {
    console.error(`[${FILE_NAME}] Error removing appletOnLoadId in ${relativePath}:`, error);
    return fileContent;
  }
}

export function getInnerIndent(content) {
  // 提取对象内部属性的缩进格式
  const match = content.match(/{\s*\n(\s+)/);
  return match ? match[1] : '  '; // 默认2空格缩进
}

// 后来觉得按行分割、按行插入的做法更好，但既然 DeepSeek 已经生成了，就继续按这个很丑的思路做了
export function findInsertPositionAndIndent(fileContent, geogebraObjContent, propEnd, parentEnd) {
  const normalInnerIndent = getInnerIndent(geogebraObjContent);
  // 在当前属性后查找最佳插入点
  let pos = propEnd;

  // 跳过可能存在的逗号
  while (pos < parentEnd && /[,\s]/.test(fileContent[pos])) {
    pos++;
  }

  // 如果是最后一个属性，在结束前插入，且前缀缩进差了2，后缀缩进要相应减2。其他情况，则前缀缩进不需要补，后缀缩进正常处理即可
  if (pos >= parentEnd - 1) {
    const suffixIndent = ' '.repeat(normalInnerIndent.length - 2);
    return { prefixIndentDiff: '  ', insertPosition: parentEnd - 1, suffixIndent };
  }

  // 确保插入点前面有逗号
  if (fileContent[propEnd] !== ',') {
    return { prefixIndentDiff: '', insertPosition: propEnd, suffixIndent: normalInnerIndent };
  }

  return { prefixIndentDiff: '', insertPosition: pos, suffixIndent: normalInnerIndent };
}

export function applyPatches(codeAfterDeletion, patches) {
  if (!patches.length) {
    return codeAfterDeletion;
  }
  let codeAfterAddition = codeAfterDeletion;
  // 倒序排序，确保 patch.position 不受影响
  patches.sort((a, b) => b.position - a.position).forEach((patch) => {
    codeAfterAddition =
      codeAfterAddition.slice(0, patch.position) +
      patch.content +
      codeAfterAddition.slice(patch.position);
  });
  return codeAfterAddition;
}

export function generateCollectionFile(functionSourceMap) {
  // 排序可让 git diff 更少
  const hashMapContent = Object
    .entries(functionSourceMap)
    .sort()
    .reduce((content, [key, val]) => {
      const escapedVal = JSON.stringify(val).slice(1, -1).replace(/'/g, '\\\'');
      return content + `  '${key}': decodeURI('${escapedVal}'),\n`;
    }, '');
  const collectionContent = `// AUTO-GENERATED BY ${FILE_NAME}
export default {
${hashMapContent}};
`;
  fs.writeFileSync(collectionFilePath, collectionContent, 'utf-8');
}

export function getAddedAppletOnLoadIdsCode(
  fileContent,
  relativePath,
  functionSourceMap
) {
  const codeAfterDeletion = removeExistingAppletOnLoadIds(fileContent, relativePath);
  const patches = [];

  const ast = parse(codeAfterDeletion, {
    sourceType: 'module',
    plugins: ['jsx'],
  });

  let functionCount = 0;

  // 遍历 AST 查找 appletOnLoad 函数
  traverse(ast, {
    ObjectProperty(path) {
      if (!t.isIdentifier(path.node.key, { name: 'appletOnLoad' })) return;
      if (!t.isArrowFunctionExpression(path.node.value) && !t.isFunctionExpression(path.node.value)) return;

      const geogebraConfig = path.parent;

      const functionId = getFunctionId(geogebraConfig, relativePath, functionCount);
      functionCount++;

      // 获取函数体源码
      const { start, end } = path.node.value;
      const functionSource = codeAfterDeletion.slice(start, end);

      functionSourceMap[functionId] = getProcessedFunctionSource(functionSource);

      const geogebraObjectPath = path.parentPath.findParent(p => t.isObjectExpression(p.node));
      if (!geogebraObjectPath) return;
      const geogebraObject = geogebraObjectPath.node;

      const geogebraObjContent = codeAfterDeletion.slice(geogebraObject.start, geogebraObject.end);
      // 从 geogebraConfig 之尾开始往后找插入位置和缩进
      const { insertPosition, prefixIndentDiff, suffixIndent } = findInsertPositionAndIndent(
        codeAfterDeletion,
        geogebraObjContent,
        geogebraConfig.end,
        geogebraObject.end
      );

      if (insertPosition) {
        patches.push({
          position: insertPosition,
          content: `${prefixIndentDiff}appletOnLoadId: '${functionId}',\n${suffixIndent}`,
        });
      }
    },
  });

  // 3. 将修改后的 AST 写回文件
  const codeAfterAddition = applyPatches(codeAfterDeletion, patches);
  return codeAfterAddition;
}

export async function geogebraSrcCodeCollect() {
  // 存储所有提取的函数源码
  const functionSourceMap = {};

  // 1. 递归查找所有课件配置文件
  const configFiles = await glob(CONFIG_FILES_PATTERN, {
    ignore: ['node_modules/**'],
  });

  // 2. 处理每个课件配置文件
  for (const filePath of configFiles) {
    const fileContent = fs.readFileSync(filePath, 'utf-8');
    const relativePath = path.relative(process.cwd(), filePath);

    try {
      const modifiedCode = getAddedAppletOnLoadIdsCode(
        fileContent,
        relativePath,
        functionSourceMap
      );
      // 防止 watcher 导致的递归
      if (modifiedCode !== fileContent) {
        fs.writeFileSync(filePath, modifiedCode);
      }
    } catch (error) {
      console.error(`[${FILE_NAME}] Error processing ${relativePath}:`, error);
    }
  }

  // 4. 生成映射文件
  generateCollectionFile(functionSourceMap);

  console.log(`[${FILE_NAME}] Generated appletOnLoad mapping: ${collectionFilePath}`);
}

export function setupWatcher() {
  console.log(`[${FILE_NAME}] Setting up file watcher...`);

  const watcher = chokidar.watch('src', {
    ignored: (path, stats) => {
      return stats?.isFile() && !['config.js', 'Config.js', 'config.jsx', 'Config.jsx'].some((v) => path.endsWith(v));
    },
    ignoreInitial: true,
    persistent: true,
  });

  watcher
    .on('add', (filePath) => {
      console.log(`[${FILE_NAME}] File added: ${filePath}`);
      geogebraSrcCodeCollect();
    })
    .on('change', (filePath) => {
      console.log(`[${FILE_NAME}] File changed: ${filePath}`);
      geogebraSrcCodeCollect();
    })
    .on('unlink', (filePath) => {
      console.log(`[${FILE_NAME}] File removed: ${filePath}`);
      geogebraSrcCodeCollect();
    });

  return watcher;
}

async function main() {
  try {
    // 初始处理
    await geogebraSrcCodeCollect();

    const watcher = setupWatcher();

    // 优雅关闭
    process.on('SIGINT', () => {
      console.log(`\n[${FILE_NAME}] Closing watcher...`);
      watcher.close();
      process.exit();
    });
  } catch (err) {
    console.error(`[${FILE_NAME}]`, 'Error:', err);
    process.exit(114514);
  }
}

if (import.meta.filename === process.argv[1]) {
  main();
}
