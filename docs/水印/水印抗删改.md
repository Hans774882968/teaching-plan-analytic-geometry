TODO: 探索失败，暂时懒得做这个，因为优先级不是很高。

好吧。我手打的版本也失败了。它做不到字符串留空时不显示。代码暂时放这里了。

```js
import { useEffect, useRef } from 'react';
import Watermark from '@uiw/react-watermark';
import { createRoot } from 'react-dom/client';

export default function TpmWatermark({ ...rest }) {
  const containerRef = useRef(null);
  const rRootRef = useRef(null);
  const wmRef = useRef(null);

  useEffect(() => {
    if (!containerRef.current) return;
    if (!rRootRef.current) {
      rRootRef.current = createRoot(containerRef.current);
    }
    rRootRef.current.render(
      <Watermark
        ref={wmRef}
        style={{ height: '100vh' }}
        {...rest}
      />
    );

    const ob = new MutationObserver(() => {
      if (!document.body.contains(containerRef.current)) {
        document.body.appendChild(containerRef.current);
      }
    });
    ob.observe(document.body, { childList: true, subtree: true });

    return () => {
      ob.disconnect();
    };
  }, [rest]);

  if(!rest.content) return null;

  return (
    <div ref={containerRef} className="fixed inset-0 pointer-events-none z-9999" />
  );
}
```

`@uiw/react-watermark`没有任何抗删改能力。我现在手打这个版本只能应对删除`containerRef`的情况，其他情况一律无法应对。

让通义千问改我现在的版本，改出的结果如下。实测能力和我现在手打这个一样菜。

https://chat.qwen.ai/c/fe6c4715-67e4-48ab-a5ba-9b0c03151dd8

> 大佬，你是一名专家前端工程师，精通前端工程化。请叫我hans7。我封装了@uiw/react-watermark的组件，希望赋予该组件抗DOM修改/删除去掉水印的能力。代码如下：

> 希望你帮我修改代码，分别监听containerRef和wmRef的删除和DOM属性变化，并重新插入相同DOM元素

```jsx
import { useEffect, useRef } from 'react';
import Watermark from '@uiw/react-watermark';
import { createRoot } from 'react-dom/client';

// 预定义常量避免重复创建
const CONTAINER_CLASS = 'fixed inset-0 pointer-events-none z-9999';
const WATERMARK_ATTRS = ['class', 'style', 'width', 'height'];

// 重渲染函数（独立于useEffect避免闭包陷阱）
const rerenderWatermark = (containerRef, rRootRef, wmRef, observersRef, rest) => {
  if (!containerRef.current || !rRootRef.current) return;

  // 关键防护：重渲染前断开所有Observer防止循环触发
  observersRef.current.container?.disconnect();
  observersRef.current.wm?.disconnect();

  // 重新渲染水印（保留原始props）
  rRootRef.current.render(
    <Watermark
      ref={wmRef}
      style={{ height: '100vh' }}
      {...rest}
    />
  );

  // 重连Observer（确保新DOM被监控）
  if (containerRef.current) {
    observersRef.current.container?.observe(containerRef.current, {
      attributes: true,
      attributeFilter: ['class'],
      childList: true,
      subtree: true,
    });
  }
  if (wmRef.current) {
    observersRef.current.wm?.observe(wmRef.current, {
      attributes: true,
      attributeFilter: WATERMARK_ATTRS,
    });
  }
};

export default function TpmWatermark({ ...rest }) {
  const containerRef = useRef(null);
  const rRootRef = useRef(null);
  const wmRef = useRef(null); // 明确类型为HTMLElement
  // 用于存储MutationObserver实例（避免闭包问题）
  const observersRef = useRef({});

  useEffect(() => {
    if (!containerRef.current) return;

    // 初始化渲染
    if (!rRootRef.current) {
      rRootRef.current = createRoot(containerRef.current);
    }
    rRootRef.current.render(
      <Watermark
        ref={wmRef}
        style={{ height: '100vh' }}
        {...rest}
      />
    );

    // 1. 监控containerRef（水印容器）
    const containerObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        // 处理容器属性篡改（仅重置关键class）
        if (mutation.type === 'attributes' && mutation.attributeName === 'class') {
          // 仅当class被篡改时重置（避免React正常更新触发）
          if (containerRef.current?.className !== CONTAINER_CLASS) {
            // 智能重置：先断开Observer防止重置操作触发新mutation
            containerObserver.disconnect();
            containerRef.current.className = CONTAINER_CLASS;
            containerObserver.observe(containerRef.current, {
              attributes: true,
              attributeFilter: ['class'],
              childList: true,
              subtree: true,
            });
          }
        }

        // 处理水印元素被删除
        if (mutation.type === 'childList') {
          // 检查wmRef是否仍在容器内（关键防护点）
          if (wmRef.current && !containerRef.current?.contains(wmRef.current)) {
            rerenderWatermark(containerRef, rRootRef, wmRef, observersRef, rest);
            return; // 避免后续mutation处理
          }
        }
      }
    });

    // 2. 监控wmRef（水印核心元素）
    const wmObserver = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.type === 'attributes') {
          // 检测到关键属性被篡改 → 触发重渲染
          rerenderWatermark(containerRef, rRootRef, wmRef, observersRef, rest);
          return;
        }
      }
    });

    // 3. 监控body（容器被移除时恢复）
    const bodyObserver = new MutationObserver(() => {
      if (!document.body.contains(containerRef.current)) {
        document.body.appendChild(containerRef.current);
      }
    });

    // 启动所有 Observer
    observersRef.current = {
      container: containerObserver,
      wm: wmObserver,
      body: bodyObserver,
    };

    // 初始化监控
    containerObserver.observe(containerRef.current, {
      attributes: true,
      attributeFilter: ['class'], // 仅监控class防style冲突
      childList: true,
      subtree: true,
    });

    // 确保wmRef已挂载再监控（避免空引用）
    if (wmRef.current) {
      wmObserver.observe(wmRef.current, {
        attributes: true,
        attributeFilter: WATERMARK_ATTRS,
      });
    }

    bodyObserver.observe(document.body, {
      childList: true,
      subtree: true,
    });

    return () => {
      Object.values(observersRef.current).forEach(observer => {
        observer?.disconnect();
      });
      // 避免内存泄漏
      // rRootRef.current?.unmount(); // TODO: 不知道为什么会报错
    };
  }, [rest]);

  return (
    <div
      ref={containerRef}
      className={CONTAINER_CLASS}
    />
  );
}
```
