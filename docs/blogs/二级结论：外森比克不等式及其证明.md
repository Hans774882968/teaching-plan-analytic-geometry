---
tags:
  - 海伦公式
  - 外森比克不等式
  - 辅助角公式
title: 二级结论：外森比克不等式及其证明
ctime: '1757433129794'
ctime_f: '2025-09-09 23:52:09'
mtime: '1758267697785'
mtime_f: '2025-09-19 15:41:37'
---
## 外森比克不等式

https://zhuanlan.zhihu.com/p/613213745

$a^2 + b^2 + c^2 \geq 4\sqrt{ 3 }S$

证明思路很简单，已知三边，自然是想办法把它和海伦公式挂钩。左边用均值不等式变成 $a^2+b^2+c^2 \geq \frac{(a+b+c)^2}{3}$ ，然后就是想办法把右边变成海伦公式的样子。

## 加权形式的一个简洁的证明

https://www.zhihu.com/question/663916619

$xa^2 + yb^2 + zc^2 \geq 4\sqrt{ xy+yz+zx }S$

这个证明很简洁，我仅在此简单批注。面积用 $\frac{ab\sin C}{2}$ 表示，所以我们自然会用余弦定理展开 $c^2$ 。 我们希望左边每一项都有ab，对于 $(x+z)a^2+(y+z)b^2$ 这个唯一不满足的项，我们用均值不等式就能让它也有ab。于是我们只需要处理 $\sqrt{ (x+z)(y+z) }-z\cos C$ 。这个放缩可以用辅助角公式，我们设 $m\sin C+z\cos C \leq (x+z)(y+z)$ ，即可拿到对应的m，完成放缩。最后整理一下： $\sqrt{ (x+z)(y+z)-z^2 } = \sqrt{ xy+yz+zx }$

## 建系证明其加权形式

[[已知三角形满足a2+b2+2c2=8，求面积最小值]] 这题有一个建系做法，我们将其扩展一下，就能用来证明上述加权形式。步骤如下：

1. 把 $b^2,\ c^2$ 换成关于a的式子，并化简为圆的标准方程
2. 写出面积的最大值函数。其主体部分是关于 $a^2$ 的二次函数
3. 直接套二次函数结论，写出最大面积的表达式

这个计算量应该还好，但我也懒得算了，交给通义千问老师了。提示词

>大佬，你是一名数学科研工作者，精通sympy。请叫我hans7。对三角形ABC建立平面直角坐标系，设C(0,0),B(a,0),A(X,Y)，AC=b，AB=c，并且已知约束方程xa^2+yb^2+zc^2=w，其中x,y,z,w是常数。那么约束方程是一个圆的方程。请写Python代码，用sympy把约束方程化为圆的标准方程。然后取圆的半径r，求出三角形面积最大值的关于a的函数。最后求这个函数的最大值

它给的代码质量不太好，跑不通，但修修补补也能跑出结果。

面积最大值函数：

$$
\frac{a \sqrt{\frac{- a^{2} x y - a^{2} x z - a^{2} y z + w y + w z}{y^{2} + 2 y z + z^{2}}}}{2}
$$

使面积最大的a

$$
\sqrt{\frac{w (y+z)}{2 x y + 2 x z + 2 y z}}
$$

最大面积 $\frac{w}{4\sqrt{ xy+xz+yz }}$

相关代码

```python
import sympy as sp

# 定义符号
X, Y = sp.symbols('X Y', real=True)
a, x, y, z, w = sp.symbols('a x y z w', real=True, constant=True)

b2 = X**2 + Y**2
c2 = (X - a)**2 + Y**2

# 约束方程
constraint = x * a**2 + y * b2 + z * c2 - w

# 展开并整理成关于 X, Y 的方程
eq = sp.expand(constraint)
eq_simplified = sp.collect(eq, [X, Y])

# 标准化：除以 (y + z)，假设 y + z ≠ 0
denom = y + z
eq_normalized = sp.expand(eq_simplified / denom)

print("约束方程系数归一后：")
sp.pprint(eq_normalized)

coeff_X2 = eq_normalized.coeff(X, 2)
coeff_Y2 = eq_normalized.coeff(Y, 2)
coeff_X = eq_normalized.coeff(X, 1)
constant_term = eq_normalized - coeff_X2 * X**2 - coeff_Y2 * Y**2 - coeff_X * X

# 配方
h = -coeff_X / (2 * coeff_X2)  # X 的偏移量
# 计算半径平方
r_squared_expr = sp.simplify(h**2 - constant_term / coeff_X2)
# 化为圆的标准形式
eq_circle = (X - h)**2 + Y**2 - r_squared_expr

print("\n圆的标准方程形式：")
sp.pprint(eq_circle)

# 定义面积最大值函数
r_expr = sp.sqrt(r_squared_expr)
s_max = sp.Rational(1, 2) * a * r_expr

print("\n面积最大值函数 s_max(a) = ")
sp.pprint(s_max)
sp.print_latex(s_max)

a_var = sp.Symbol('a', real=True, positive=True)
s_max_func = s_max.subs(a, a_var)
# 求导
ds_da = sp.diff(s_max_func, a_var)

# 解导数为0
critical_points = sp.solve(ds_da, a_var)
print("\n临界点：")
sp.pprint(critical_points)

# 选取正实数解（物理意义）。确实没想到怎么优雅取到正的，就先这么写了
a_opt = critical_points[1]

if a_opt is None:
    print("未找到正实数临界点qwq")
else:
    print(f"\n使面积最大的 a ：")
    sp.pprint(a_opt)
    sp.print_latex(a_opt)
    # 代入求最大面积
    s_max_value = s_max_func.subs(a_var, a_opt)
    s_max_value_simplified = sp.simplify(s_max_value)
    print("\n最大面积 = ")
    sp.pprint(s_max_value_simplified)
```
